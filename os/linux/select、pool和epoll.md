I/O多路复用,就通过一种机制，可以使一个线程监视多个socket描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，poll，epoll都是IO多路复用的机制。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。


select和poll每次调用时都需要复制一份fd集合到内核空间，在内核空间需要不断论询所有fd集合，看看有没有fd就绪。poll相对于select的优势就是没有最大fd数量的限制，而select默认只能使用1024个fd。

epoll分为3步:1.epoll_create创建epoll对象 2.epoll_ctl注册移除感兴趣的事件 3.epoll_wait等待就绪事件。

epoll只有在使用epoll_ctl注册移除事件时，才会复制一份fd集合到内核，并且在所有fd上注册感兴趣事件的回调，当有fd就绪时会执行回调，将fd加入到就绪列队中。内核会不断使用epoll_wait轮询就绪队列看看是否不为空。

所以，相比较select和poll，epoll只需要轮询判断就绪队列是否为空就可以了，更节约CPU。而且epoll只需在注册事件时将fd复制一份到内核即可，不用每次调用都复制。

epoll分为水平触发和边缘触发。水平触发是指如果epool_wait一次没有把数据读写完成下次还能继续读写；边缘触发是指如果没有一次读取完成下次也不会在通知。所以如果系统中大量就绪的的而你不关注的fd时，使用水平触发方式，会影响检索自己关注的fd的销量。

