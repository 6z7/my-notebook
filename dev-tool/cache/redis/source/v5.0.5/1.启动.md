# Redis启动

[redis-server](https://gitee.com/glzsk/redis5-cmake/blob/master/src/server.c)的启动过程(main函数执行)，主要包括:

1. 时区和随机数的初始化
2. 初始化server配置的默认值
3. module初始化
4. 如果处于哨兵模式，则初始化哨兵
5. 是否仅执行redis-check-rdb
6. 是否仅执行redis-check-aof
7. 解析命令行参数，从指定的配置文件中加载配置
8. 是否作为守护进程启动
9. Server初始化
10. pid文件、acsii logo、检查设置的tcp backlog是否有效
11. 非哨兵模式

    * 检测linux内存分配策略
    * 加载module
    * 从磁盘加载aof或rdb，优先aof 

    哨兵模式   

    * 为启动哨兵做准备
12. 启动事件循环 
13. 事件循环结束，退出程序  

## Server初始化

初始化过程做的事非常多，主要包括：

0. 注册终止信号处理函数
1. 初始化Server配置文件中的各种数据
2. 创建一些字符串类型的redisObject实例，避免重复创建。如一些错误提示、字符
3. 创建事件循环处理器

    * 每个客户端连接对应一个文件事件
    * 创建epoll
4. 分配数据库结构所需空间
5. 根据配置创建socket监听、UNIX Domain Socket
6. 初始化配置的db中的相关集合
7. 初始化LRU缓冲池
8. Server中其它数据初始化
9. 创建一个每秒触发一次的时间事件，加入到event loop中，用来执行serverCron
10. 订阅epoll上的socket可读事件,加入到event loop中
11. 如果AOF开启，则打开AOF文件
12. 未指定内存时，32位机器限制3GB
13. 如果集群开启，则初始化集群
14. 初始化副本script缓存
15. lua脚本引擎初始化
16. 慢查询日志初始化
17. 延迟监控初始化，记录延迟的事件
18. 创建后台线程池

## 事件循环

redis自己定义了一层事件处理的抽象，编译时根据不同的系统，,使用不同的实现方式。这里看下linux下基于epoll的事件循环。

事件循环中主要完成:

1. 处理网络事件

    * 根据最先需要执行的定时任务,计算获取触发事件时最大可阻塞时间,如果标记了非阻塞，则调用后立即返回不会阻塞
    * 遍历获取到的网络事件，默认优先处理读事件，再处理写事件。如果进行了特殊标记，可以反过来处理。   

2. 处理时间事件

    * 检测系统时钟是否往前拨了。如果是则修改所有定时任务的触发时间，目的是尽快执行所有的定时任务
    * 遍历所有的定时任务，移除其中已经执行过的定时任务；执行已经触发的定时任务；如果该定时任务还需要继续执行则更新下次触发的时间，如果不需要继续执行则标记为已经执行完成，以便下次从链表中删除该定时任务

## 退出main函数

事件循环结束后，释放对应的epoll和分配的内存空间，退出main函数，执行结束。一般正常情况是不会退出事件循环的。