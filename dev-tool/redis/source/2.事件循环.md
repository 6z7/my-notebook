
redis自己定义了一层事件处理的抽象，编译时根据不同的系统，,使用不同的实现方式。我们主要看下linux下的epoll实现。

事件循环中主要完成:

* 根据最先需要执行的定时任务,计算epoll_wait最大可阻塞时间
* 将触发的socket事件保存到eventLoop->fired
* 循环处理触发的事件
* 遍历定时任务链表执行到时的定时任务、移除无效的定时任务


## aeMain

一直循环直到stop

    void aeMain(aeEventLoop *eventLoop) {
        eventLoop->stop = 0;
        while (!eventLoop->stop) {
            if (eventLoop->beforesleep != NULL)
                eventLoop->beforesleep(eventLoop);
            aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
        }
    }

## aeProcessEvents

根据最先需要触发的定时任务,计算epoll_wait最大可阻塞时间,如果获取到事件则执行触发的事件,最后在执行定时任务。


    int aeProcessEvents(aeEventLoop *eventLoop, int flags)
    {
        int processed = 0, numevents;
         
        //如果不处理定时器事件，也不处理文件事件，就直接返回
        if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;
 
        //如果有socket事件||要处理定时器事件并且没有设置不阻塞标志
        if (eventLoop->maxfd != -1 ||
            ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {
            int j;
            aeTimeEvent *shortest = NULL;
            struct timeval tv, *tvp;

            //时间事件&&没有设置非阻塞
            if (flags & AE_TIME_EVENTS && !(flags & AE_DONT_WAIT))
                shortest = aeSearchNearestTimer(eventLoop); //查找最先需要触发的时间事件
            if (shortest) {
                long now_sec, now_ms;

                aeGetTime(&now_sec, &now_ms);
                tvp = &tv;

                /* How many milliseconds we need to wait for the next
                * time event to fire? */
                //距离触发事件还剩多少毫秒
                long long ms =
                    (shortest->when_sec - now_sec)*1000 +
                    shortest->when_ms - now_ms;

                if (ms > 0) {
                    tvp->tv_sec = ms/1000;
                    tvp->tv_usec = (ms % 1000)*1000;
                } else {
                    tvp->tv_sec = 0;
                    tvp->tv_usec = 0;
                }
            } else {                
                //如果设置了不阻塞标志，阻塞时间为0，表示不阻塞
                if (flags & AE_DONT_WAIT) {
                    tv.tv_sec = tv.tv_usec = 0;
                    tvp = &tv;
                } else {                 
                    //NULL一致阻塞
                    tvp = NULL; /* wait forever */
                }
            }         
            //等待获取触发的事件直到超时,超时时间可以有最近需要执行的定时任务确定
            numevents = aeApiPoll(eventLoop, tvp);         
            if (eventLoop->aftersleep != NULL && flags & AE_CALL_AFTER_SLEEP)
                eventLoop->aftersleep(eventLoop);

            for (j = 0; j < numevents; j++) {
                aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];
                int mask = eventLoop->fired[j].mask;
                int fd = eventLoop->fired[j].fd;
                int fired = 0;  
                if (!invert && fe->mask & mask & AE_READABLE) {
                    fe->rfileProc(eventLoop,fd,fe->clientData,mask);
                    fired++;
                }

                /* Fire the writable event. */
                if (fe->mask & mask & AE_WRITABLE) {
                    if (!fired || fe->wfileProc != fe->rfileProc) {
                        fe->wfileProc(eventLoop,fd,fe->clientData,mask);
                        fired++;
                    }
                }

                /* If we have to invert the call, fire the readable event now
                * after the writable one. */
                if (invert && fe->mask & mask & AE_READABLE) {
                    if (!fired || fe->wfileProc != fe->rfileProc) {
                        fe->rfileProc(eventLoop,fd,fe->clientData,mask);
                        fired++;
                    }
                }

                processed++;
            }
        }        
        //触发定时任务
        if (flags & AE_TIME_EVENTS)
            processed += processTimeEvents(eventLoop);

        //处理了多少个事件
        return processed;
    }

## processTimeEvents

遍历定时任务链表，移除无效的定时任务时会触发回调，执行到时的定时任务，对于还需要下次执行的任务计算触发时间。

    //处理定时事件
    static int processTimeEvents(aeEventLoop *eventLoop) {
        int processed = 0;
        aeTimeEvent *te;
        long long maxId;
        time_t now = time(NULL);
      
        //如果系统时钟偏移 则强制定时任务的尽快执行
        if (now < eventLoop->lastTime) {
            te = eventLoop->timeEventHead;
            while(te) {
                te->when_sec = 0;
                te = te->next;
            }
        }
        eventLoop->lastTime = now;

        te = eventLoop->timeEventHead;
        maxId = eventLoop->timeEventNextId-1;
        while(te) {
            long now_sec, now_ms;
            long long id;
        
            //删除无效的定时任务
            if (te->id == AE_DELETED_EVENT_ID) {
                aeTimeEvent *next = te->next;
                if (te->prev)
                    te->prev->next = te->next;
                else
                    eventLoop->timeEventHead = te->next;
                if (te->next)
                    te->next->prev = te->prev;
                //回调
                if (te->finalizerProc)
                    te->finalizerProc(eventLoop, te->clientData);
                zfree(te);
                te = next;
                continue;
            }      
            //当前这段逻辑无效,应为时间事件是向链表头部方向新增,LIFO队列
            if (te->id > maxId) {
                te = te->next;
                continue;
            }
            //获取当前时间
            aeGetTime(&now_sec, &now_ms);
            //定时事件触发
            if (now_sec > te->when_sec ||
                (now_sec == te->when_sec && now_ms >= te->when_ms))
            {
                int retval;

                id = te->id;
                retval = te->timeProc(eventLoop, id, te->clientData);
                processed++;
                if (retval != AE_NOMORE) {
                    //计算下次执行的时间
                    aeAddMillisecondsToNow(retval,&te->when_sec,&te->when_ms);
                } else {
                    te->id = AE_DELETED_EVENT_ID;
                }
            }
            te = te->next;
        }
        return processed;
    }


## next

目前我们已经了解了事件循环的过程，下面还需要看下服务端是如何处理客户端的事件(命令)的。
 

