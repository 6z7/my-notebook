这节主要是总体看下[redis-server](https://gitee.com/glzsk/redis5-cmake/blob/master/src/server.c)的启动过程，主要包括:

1. 与配置文件命令参数解析
2. server初始化
3. 开始事件循环

## 配置文件处理

这个过程比较简单主要就是解析命令行参数与文件文件，将配置保存到redisServer结构中。


## server初始化

初始化过程做的事非常多，主要包括：

1. 创建事件处理器(el)
2. 监听指定的端口
3. 创建定时任务
4. 订阅el上的AE_READABLE事件
5. 集群初始化
6. lua初始化
7. slowlog初始化
8. db初始化
9. 创建一些共享对象
10. ......


        //初始化server
        void initServer(void) { 
        
            createSharedObjects();//共享的一些对象,放到了shared结构中
            adjustOpenFilesLimit();//自适应file limit
            //初始化事件处理器
            server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);//创建event loop
            if (server.el == NULL) {
                serverLog(LL_WARNING,
                    "Failed creating the event loop. Error message: '%s'",
                    strerror(errno));
                exit(1);
            }
            server.db = zmalloc(sizeof(redisDb)*server.dbnum);

            /* Open the TCP listening socket for the user commands. */
            // 监听指定端口绑定ip
            if (server.port != 0 &&
                listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)
                exit(1);

            /* Open the listening Unix domain socket. */
            if (server.unixsocket != NULL) {
                unlink(server.unixsocket); /* don't care if this fails */
                server.sofd = anetUnixServer(server.neterr,server.unixsocket,
                    server.unixsocketperm, server.tcp_backlog);
                if (server.sofd == ANET_ERR) {
                    serverLog(LL_WARNING, "Opening Unix socket: %s", server.neterr);
                    exit(1);
                }
                anetNonBlock(NULL,server.sofd);
            }

            /* Abort if there are no listening sockets at all. */
            if (server.ipfd_count == 0 && server.sofd < 0) {
                serverLog(LL_WARNING, "Configured to not listen anywhere, exiting.");
                exit(1);
            }

            /* Create the Redis databases, and initialize other internal state. */
            //初始化redis db
            for (j = 0; j < server.dbnum; j++) {
                server.db[j].dict = dictCreate(&dbDictType,NULL);
                server.db[j].expires = dictCreate(&keyptrDictType,NULL);
                server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);
                server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);
                server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
                server.db[j].id = j;
                server.db[j].avg_ttl = 0;
                server.db[j].defrag_later = listCreate();
            }
            evictionPoolAlloc(); /* Initialize the LRU keys pool. */ 

            /* Create the timer callback, this is our way to process many background
            * operations incrementally, like clients timeout, eviction of unaccessed
            * expired keys and so forth. */
            //注册定时任务处理一些后台操作
            if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
                serverPanic("Can't create event loop timers.");
                exit(1);
            }

            /* Create an event handler for accepting new connections in TCP and Unix
            * domain sockets. */
            for (j = 0; j < server.ipfd_count; j++) {
                //注册指定的事件到epoll上
                if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
                    acceptTcpHandler,NULL) == AE_ERR)
                    {
                        serverPanic(
                            "Unrecoverable error creating server.ipfd file event.");
                    }
            }  

            //集群初始化
            if (server.cluster_enabled) clusterInit();

            replicationScriptCacheInit();
            //lua初始化
            scriptingInit(1);
            //慢查询日志初始化
            slowlogInit();
            latencyMonitorInit();
            bioInit();
            //初始完成使用了多少字节内存
            server.initial_memory_usage = zmalloc_used_memory();
         }


## 开始事件循环

通过一个while循环处理socket事件与定时事件

    void aeMain(aeEventLoop *eventLoop) {
        eventLoop->stop = 0;
        while (!eventLoop->stop) {
            if (eventLoop->beforesleep != NULL)
                eventLoop->beforesleep(eventLoop);
            aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
        }
    }

## next

执行完以上流程，redis已经在监听指定的端口,等待处理客户端请求。下一节我们先来看下redis是如何处理socket事件与定时事件的。
