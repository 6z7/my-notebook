## 将Redis用作LRU缓存

将Redis用作缓存时，通常很方便
的做法是在添加新数据时自动将旧数据逐出。此行为在开发人员社区中是众所周知的，因为它是流行的memcached缓存系统的默认行为。

从Redis版本4.0开始，引入了新的LFU（最不常用）驱逐策略。 本文档中有单独章节对此进行介绍。

## Maxmemory配置指令

maxmemory配置redis最大可用的内存，可以通过`redis.conf`文件配置，也可以使用`config set`命令在运行时进行配置。

例如，为了配置100 MB的内存限制，可以在redis.conf文件中使用以下指令。

```
maxmemory 100mb
```
将maxmemory设置为零意味着没有内存限制。 这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

当达到指定的最大内存时，可以在称为策略的不同行为之间进行选择。 Redis可能会对使用使用更多内存的命令返回错误，或者它可以逐出某些旧数据，以便在每次添加新数据时满足内存限制。

## 驱逐政策

当使用了`maxmemory-policy`配置指令，在达到最大内存限制时，redis会按照配置进行处理。

有以下可用策略:

* noeviction:当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时，返回错误

* allkeys-lru:通过尝试先删除较不常用的(LRU)键来为添加的新数据腾出空间。

* volatile-lru:通过尝试删除带有过期时间的较不常用的(LRU)键来为添加的新数据腾出空间。

* allkeys-random:随机删除key

* volatile-random:随机删除带有过期时间的key

* volatile-ttl:删除带有过期时间的key，有限移除ttl短的key

如果没有满足驱逐条件的key，那么volatile-lru, volatile-random和volatile-ttl将变得和noeviction策略一样。

选择正确的逐出策略很重要，具体取决于应用程序的访问模式，但是您可以在应用程序运行时在运行时重新配置该策略，并使用Redis INFO输出监视缓存未命中和命中的次数，以调整设置。

## 驱逐过程如何进行

重要的是要了解驱逐过程的工作方式，如下：

* 客户端运行新命令，从而添加更多数据。
* Redis会检查内存使用情况，如果大于最大内存限制，则会根据策略逐出密钥。
* 执行新命令，依此类推

## 近似LRU算法

Redis的LRU算法不是精确的实现。 这意味着Redis无法选择最好的驱逐候选者，即过去访问最多的访问者。 取而代之的是，它将尝试对LRU算法进行近似处理，方法是对少量key进行采样，然后从采样的key中驱出最好的（访问时间最旧）key。

但是，自Redis 3.0起，对该算法进行了改进，使其还可以收集一批优秀的驱逐对象。 这改善了算法的性能，使其能够更接近真实的LRU算法的行为。

Redis LRU算法的重要意义在于，可以通过更改样本数量来检查每次逐出，从而调整算法的精度。此参数由以下配置指令控制：

```
maxmemory-samples 5
```
