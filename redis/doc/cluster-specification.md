[Redis集群规范](https://redis.io/topics/cluster-spec)
---
欢迎使用Redis集群规范，。在这里你可以找到Redis集群的算法和设计原理相关信息。这个文档是与集群的实现保持同步的。

## 设计的主要性质和原理

### 集群的目标

Redis集群是Redis的分布式实现，有如下目标，按照设计的重要性排序：

* 高性能和线性扩展到1000节点。没有代理，异步复制被使用，也没有对值执行合并的操作。

* 可接受的写安全程度:系统尝试(以最大努力的方式)保留来自与大多数主节点连接的客户端的所有写操作。通常有一些小窗口期，可能丢失已经确认的写入。当客户端位于少数分区时，丢失已经确认的写入的窗口会更大。

* 可用性:Redis集群能够在大多数主节点都可以访问的分区中生存，对于不能访问的主节点至少要有有一个可以访问的从节点。使用副本漂移，可以将副本从拥有多个副本的主节点下迁移到其它主节点。

本文档中描述的是在Redis 3.0或更高版本中实现的。

## 实现的子集

Redis集群实现了非分布式Redis支持的所有单key命令。执行复杂操作(如集合类型联合或交集)的命令也会被实现，只要这些key被hash到同一个slot。

Redis集群提出了一种hash tag的概念，用于强制将一些key存储到相同的slot。在手动重新分片期间，多key操作可能一段时间不可用，但是单key操作是一直可用的。

Redis集群不支持多个数据库。只有数据库0，不允许使用select命令。

## 客户端与服务端在Redis集群协议中的角色

Redis集群中的节点负责存储数据，获取集群的状态，将key映射到正确的节点上。集群节点可以自动发现其它节点，检测故障节点，当故障发生时为了将从节点提升为主节点。

为了执行任务集群中的所有节点都通过Tcp总线和二进制协议连接，称为Redis集群总线。通过集群总线每个节点点都连接上了其它节点。节点使用gossip协议传播关于集群消息，以便发现新的节点，发送ping包以确保所有其它节点都正常工作，发送集群消息来通知特定的条件。集群总线还用于在集群中传播发布/订阅消息和协调用户发起的手动failoveri请求。

由于集群节点不能代理请求，使用重定向错误Move和ASK可以将client重定向其它节点。理论上client可以将集群中的所有节点发送请求，如果需要会进行重定向，因此客户机不需要保持集群的状态，但是client可以缓存slot与节点的映射关系提高性能。

## 安全写入

Redis集群主从节点间使用异步复制，最后选举为master节点拥有的数据将替换所有其它从节点的数据。总有一段窗口期可能在分区期间丢失写操作。客户端连接大多数主节点和连接少部分主节点时的窗口期是不同的。

与拥有少数主节点的分区侧的写操作相比，Redis集群努力保留连接大多数主节点的client的写操作。以下是一些场景的示例，这些场景会导致在故障期间丢失接收到的已确认的写操作:

1. 写操作到达master节点，但是由于主从之间是异步复制的，在master回复客户端之后，数据可能没有传播到从节点,如果此时master挂了，从节点被提升为master数据将丢失。
2. 另外一种理论上可能导致数据丢失的情况如下:

* 由于分区主节点不能访问
* 由于从节点的原因导致主节点挂了
* 一段时间后master又能访问了
* client缓存了旧的路由关系，可能写数据到旧的主节点，在其转为从节点之前

一个master节点要进行failover，必须是大部分master节点在至少NODE_TIMEOUT内认为它不可达。如果在这段时间内分区恢复则不会丢失写数据。当分区持续超过NODE_TIMEOUT，在少数侧执行的写数据可能会丢失。当经过NODE_TIMEOUT后还没有连接上集群，少读侧节点将拒绝写操作，因此在少数侧节点不可再用前有一个最大窗期。

## 可用性

Redis集群在分区的少数端不可用。在分区的多数侧假设至少有大多数的master和每个不可达的master至少有一个salve，那么经过NODE_TIMEOUT加从节点选举为master花费的时间后集群将重新可用。

Redis集群被设计成在集群中少数节点故障时依然能正常服务，但是对于在发生大量网络分区时依然能够使用的场景这不是一种合适的解决方案。

由N个maste节点，每个master有一个salve组成的集群，如果只有一个节点被分区集群将继续可用。当有2个节点分区时，集群可用的概率1-(1/N*2)


