
# 协程

协程(Coroutine)是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处继续运行。

相比线程而言，Go协程的成本极低。堆栈大小只有若干kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。

Go协程会复用数量更少的OS线程。即使程序有数以千计的Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS线程，并把其余Go协程都移动到这个新的OS线程。所有这一切都在运行时进行，作为程序员我们没有直接面临这些复杂的细节，而是有一个简洁的API来处理并发。

Go协程使用信道(Channel)来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件(Race Condition)。信道可以看作是Go协程之间通信的管道。

## 创建一个Go协程

创建Go协程非常简单，只需要使用`go`关键字即可

```go
func hello() {
	fmt.Println("hi,world")
}

func main() {
	go hello()
	//现在 hello() 函数与 main() 函数会并发地执行。
	//主函数会运行在一个特有的Go协程上,它称为Go主协程（Main Goroutine）
	time.Sleep(1 * time.Second)
	fmt.Println("main function")
}
```
